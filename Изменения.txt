Проблема 1: Ничья не определяется как исход игры.
Решение: 
1) Условие внутри функции bool isDraw изменено, так как она всегда возвращала false.
Было: (field[i] != CellState::Empty). 
Стало: if (field[i] == CellState::Empty)
2) Битовый флаг outcome.isOver = true ставится только внутри макроса CHECK_LINE и только в том случае, если
определён победитель. Но в случае ничьей он не ставится и ничья не определяется как исход игры.
Поэтому внутри функции TurnOutcome checkTurnOutcome в условии if (isDraw(field, field_dimension)) помимо присваивания outcome.isDraw = true,
добавлено присваивание outcome.isOver = true;
--------------------------------------------------------------------------------------------------------------------
Проблема 2:
После того как я хочу сыграть снова, выбрать другую сторону уже нельзя.
Решение:
1)В конец цикла while(!shouldExit) в int main() добавлена инициализация нового знака, 
за который игрок хочет начать снова игру player_sign = queryPlayerSign();. 
Новый знак запрашивается в условии if (!shouldExit) если игрок хочет начать новую игру.
--------------------------------------------------------------------------------------------------------------------
Проблема 3: иногда икуственный интеллект ставит свой знак прямо поверх знака игрока сразу после хода игрока.
Решение:
1) Внутри функции void processAiTurn в конце передаются параметры в функцию putSign(field, ai_sign, target / 3, target % 3).
Они неправильно опредедляются внутри putSign (строка row как столбец target / 3, а столбец column как строка target % 3).
Соответственно target / 3 и target % 3 были поменяны местами.
Было: putSign(field, ai_sign, target / 3, target % 3) Стало: putSign(field, ai_sign, target % 3, target / 3).
--------------------------------------------------------------------------------------------------------------------
Задание по выбору размера поля.
Изменено:
1) Удалена структура GameField, в который инициализировался массив поля для игры.
В структуре GameData объявляется указатель на динамический массив поля для игры CellState *field.
Объявляется размерность поля field_dimension, где общее количество клеток поля будет равно field_dimension * field_dimension.
2) Добавлена функция initField(), в которой создаётся прототип структуры GameData game_data {}.
game_data.field объявляется как указатель на динамический массив(поле для игры) new CellState[n*n], где n размерность поля, которую ввёл пользователь.
n впоследствии записывается в структуру как field_dimension и передаётся в качестве параметра в другие функции.
Функция возвращает структуру с полем для игры внутри функции runGameLoop.
3) Внутрь функций которые обрабатывают поле передаются поля структуры: game_data.field и размерность game_data.field_dimension.
Внутри функций game_data.field инициализируется как указатель CellState *field (вместо GameField& field), а game_data.field_dimension 
как переменная size_t field_dimension.
4) Константа 3, означавшая стандартную размерность поля, меняется внутри функций на переменную field_dimension.
